### 정렬. Sort 

* int 배열의 Arrays.sort 는 오름차순으로 정렬해준다 
* String 배열의 Arrays.sort 는 사전순으로 정렬해준다. 

boolean.byte.short.int.long.float.double.char 은 모두 값이 작은 순서대로 오름차순으로 정렬이 지원된다. 

* Wrapper 클래스는 Tim Sort 를 사용하게 된다. 
* Primitive sort 는 stable 이 보장되지 않는다. 
* Object sort 는 stable 이 보장된다. 

* 기본 오름차순이 아닌 내림차순 정렬을 하고 싶다면 ? 


```
Integer[] objectArray = {6,2,3,7,5,1,4};
Arrays.sort(objectArray, Collections.reverseOrder());

// object[] sort 는 Comparator 를 추가로 전달할 수 있다. 

```

* 기본 오름차순이 아닌, 내림차순 정렬을 하고 싶다면 ? 
```
Integer[] objectArray = {6,2,3,7,5,1,4};

Arrays.sort(objectArray, new Comparator<Integer>() {
      @Override
      public int compare(Integer o1, Integer o2){
          return o2-o1; -> 내림차순 정렬 
   }
});

Arays.sort(objectArray, (o1,o2) -> o2-o1);
```

* 기본 제공되는 type 이 아닌 내가 정의한 클래스를 정렬하고 싶다면 ?
```
 정렬을 하기 위해서는 두 원소를 비교해야하는데 새로 정의된 student class 의 정렬 기준을 알 수가 없다. 

 1. Comparable Integer 구현 

 Student[] students = {new Student("Alice", 20) , new Student("Bob", 22), new Sutdnet("Carol",19), new Student("Dave", 19)};
 Arrays.sort(students);

 class Student implements Comparable<Student> {
    String name;
    int age;
   
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override 
    public int compareTo(Student o) {
       if(age == o.age) 
         return name.compareTo(o.name);
      return age - o.age;
   }

  
  2. Comparator 사용 
   Arrays.sort(students, new Comparator<Student>() {
   @Override 
   public int compare(Student o1, Student o2){
     if(o1.age == o2.age) 
       return o1.name.compareTo(o2.name);
     return o1.age - o2.age;
}
});

  
 Arrays.sort(students, (o1,o2) -> {
       if(o1.age == o2.age) 
          return o1.name.compareTo(o2.name);
    return o1.age - o2.age;
});